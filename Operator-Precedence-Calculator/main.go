package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strconv"
)

type AutoGenerated struct {
	Number   []string `json:"number"`
	Operator []string `json:"operator"`
}
type Stack []string

var Operand Stack
var Operator Stack

func CheckError(err error) {
	if err != nil {
		log.Fatal(err)
	}

}
func Calculator(w http.ResponseWriter, r *http.Request) {
	body, _ := ioutil.ReadAll(r.Body)
	var data AutoGenerated
	err := json.Unmarshal(body, &data)
	CheckError(err)
	result := Calculation(data)
	pbyte, err := json.Marshal(result)
	CheckError(err)
	w.Write([]byte(pbyte))

}
func Calculation(data AutoGenerated) string {
	fmt.Println(data.Number[0])
	for i := 0; i < len(data.Number); i++ {

		Operand.Push(data.Number[i])
		fmt.Println(Operand, i)
		if i == 0 {
			continue
		}
		fmt.Println(Operand)
		for j := i - 1; j < len(data.Operator); j++ {
			if Operator.IsEmpty() {
				Operator.Push(data.Operator[j])
			} else if CheckPrecedence(data.Operator[j-1]) == 1 && CheckPrecedence(data.Operator[j]) == 1 || CheckPrecedence(data.Operator[j-1]) == 2 && CheckPrecedence(data.Operator[j]) == 2 || CheckPrecedence(data.Operator[j-1]) == 2 && CheckPrecedence(data.Operator[j]) == 1 {
				operation, _ := Operator.Pop()
				PerformOperation(operation)
				Operator.Push(data.Operator[j])
			} else if CheckPrecedence(data.Operator[j-1]) == 1 && CheckPrecedence(data.Operator[j]) == 2 {
				Operator.Push(data.Operator[j])
				fmt.Println(Operator)
			}

		}
		fmt.Println(Operand, Operator)
		break

	}
	fmt.Println(Operand, Operator)
	for !Operator.IsEmpty() {
		operation, _ := Operator.Pop()
		PerformOperation(operation)

		// operation, _ := Operator.Pop()
		// PerformOperation(operation)

	}
	result, _ := Operand.Pop()
	return result
}
func CheckPrecedence(operator string) int {
	if operator == "+" {
		return 1
	} else if operator == "-" {
		return 1
	} else if operator == "*" {
		return 2
	} else if operator == "/" {
		return 2
	}
	return 0
}
func PerformOperation(operator string) {
	val1, _ := Operand.Pop()
	inval1, _ := strconv.Atoi(val1)
	val2, _ := Operand.Pop()
	inval2, _ := strconv.Atoi(val2)
	var result int
	if operator == "+" {
		result = inval1 + inval2
	} else if operator == "-" {
		result = inval1 - inval2

	} else if operator == "/" {
		result = inval1 / inval2
	} else if operator == "*" {
		result = inval1 * inval2

	}
	Operand.Push(strconv.Itoa(result))
}

// IsEmpty: check if stack is empty
func (s *Stack) IsEmpty() bool {
	return len(*s) == 0
}

// Push a new value onto the stack
func (s *Stack) Push(str string) {
	*s = append(*s, str) // Simply append the new value to the end of the stack
}

// Remove and return top element of stack. Return false if stack is empty.
func (s *Stack) Pop() (string, bool) {
	if s.IsEmpty() {
		return "", false
	} else {
		index := len(*s) - 1   // Get the index of the top most element.
		element := (*s)[index] // Index into the slice and obtain the element.
		*s = (*s)[:index]      // Remove it from the stack by slicing it off.
		return element, true
	}
}

func main() {

	fs := http.FileServer(http.Dir("./static"))
	http.Handle("/", fs)
	http.HandleFunc("/calc", Calculator)
	fmt.Println("Server started at 9000")
	http.ListenAndServe(":9000", nil)
}

// func Calculation(data AutoGenerated) string {
// 	for i := 0; i < len(data.Number); i++ {
// 		PushOperand(data.Number[i])
// 		if i == 0 {
// 			continue
// 		}
// 		for j := i - 1; j < len(data.Operator); j++ {
// 			PushOperator(data.Operator[j])

// 			break
// 		}

// 	}
// 	return operandStack[len(operandStack)-1]

// }
// func PushOperand(operand string) {
// 	operandStack = append(operandStack, operand)
// 	fmt.Println(operandStack)
// }
// func PushOperator(operator string) {
// 	fmt.Println(operatorStack)
// 	if operatorStack == nil {
// 		fmt.Println("Length is 1")
// 		operatorStack = append(operatorStack, operator)

// 	} else {
// 		fmt.Println("Length is different")
// 		calculatedValue := PopOperator(operandStack[len(operandStack)-2], operandStack[len(operandStack)-1])
// 		PushOperand(fmt.Sprintf("%f", calculatedValue))
// 		operatorStack = append(operatorStack, operator)
// 		fmt.Println(operandStack)
// 	}

// }

// // func PopOperand(operand1, operand2 string) {
// // 	PopOperator(operand1, operand2)
// // }
// func PopOperator(operand1, operand2 string) float64 {
// 	operator := operatorStack[len(operatorStack)-1]
// 	val1, err := strconv.ParseFloat(operand1, 64)
// 	val2, err := strconv.ParseFloat(operand2, 64)
// 	CheckError(err)
// 	var result float64
// 	if operator == "+" {
// 		result = val1 + val2
// 	} else if operator == "-" {
// 		result = val1 - val2

// 	} else if operator == "/" {
// 		result = val1 / val2
// 		fmt.Println(result)

// 	} else if operator == "*" {
// 		result = val1 * val2

// 	}
// 	return result
// }
